[
  {
    "module_id": "react_signup_screen",
    "module_name": "React Sign Up Screen",
    "language": "tsx",
    "inputs": ["onSubmit", "isSubmitting", "errorMessage"],
    "outputs": ["<SignUpScreen /> component"],
    "documentation": "Reusable React sign up screen built with Material UI and react-hook-form. Validates email and password fields and reports submission state.",
    "code": "import React from 'react';\nimport { Alert, Box, Button, Stack, TextField, Typography } from '@mui/material';\nimport { useForm } from 'react-hook-form';\n\nexport interface SignUpFormValues {\n  displayName: string;\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\ninterface SignUpScreenProps {\n  onSubmit: (values: SignUpFormValues) => Promise<void> | void;\n  isSubmitting?: boolean;\n  errorMessage?: string | null;\n}\n\nexport const SignUpScreen: React.FC<SignUpScreenProps> = ({ onSubmit, isSubmitting = false, errorMessage = null }) => {\n  const { register, handleSubmit, watch, formState: { errors } } = useForm<SignUpFormValues>();\n\n  const handleFormSubmit = handleSubmit(async (values) => {\n    await onSubmit(values);\n  });\n\n  const passwordValue = watch('password');\n\n  return (\n    <Box component={'section'} maxWidth={420} mx={'auto'} mt={8} px={4} py={5} borderRadius={2} boxShadow={3} bgcolor={'background.paper'}>\n      <Typography variant={'h5'} component={'h1'} gutterBottom>Sign Up</Typography>\n      <form onSubmit={handleFormSubmit} noValidate>\n        <Stack spacing={2}>\n          <TextField\n            label={'Display Name'}\n            autoComplete={'name'}\n            {...register('displayName', { required: 'Display name is required.' })}\n            error={Boolean(errors.displayName)}\n            helperText={errors.displayName?.message}\n            fullWidth\n          />\n          <TextField\n            type={'email'}\n            label={'Email'}\n            autoComplete={'email'}\n            {...register('email', {\n              required: 'Email is required.',\n              pattern: {\n                value: /[^@ \\t\\r\\n]+@[^@ \\t\\r\\n]+\\.[^@ \\t\\r\\n]+/,\n                message: 'Enter a valid email address.'\n              }\n            })}\n            error={Boolean(errors.email)}\n            helperText={errors.email?.message}\n            fullWidth\n          />\n          <TextField\n            type={'password'}\n            label={'Password'}\n            autoComplete={'new-password'}\n            {...register('password', {\n              required: 'Password is required.',\n              minLength: { value: 8, message: 'Use at least 8 characters.' }\n            })}\n            error={Boolean(errors.password)}\n            helperText={errors.password?.message}\n            fullWidth\n          />\n          <TextField\n            type={'password'}\n            label={'Confirm Password'}\n            autoComplete={'new-password'}\n            {...register('confirmPassword', {\n              required: 'Confirm your password.',\n              validate: value => value === passwordValue || 'Passwords must match.'\n            })}\n            error={Boolean(errors.confirmPassword)}\n            helperText={errors.confirmPassword?.message}\n            fullWidth\n          />\n          {errorMessage ? <Alert severity={'error'}>{errorMessage}</Alert> : null}\n          <Button type={'submit'} variant={'contained'} size={'large'} disabled={isSubmitting}>\n            {isSubmitting ? 'Creating account...' : 'Create account'}\n          </Button>\n        </Stack>\n      </form>\n    </Box>\n  );\n};\n"
  },
  {
    "module_id": "react_login_screen",
    "module_name": "React Login Screen",
    "language": "tsx",
    "inputs": ["onSubmit", "onForgotPassword", "onNavigateToSignUp", "isSubmitting", "errorMessage"],
    "outputs": ["<LoginScreen /> component"],
    "documentation": "Authentication form for logging in users with optional navigation callbacks for password reset and sign up.",
    "code": "import React from 'react';\nimport { Alert, Box, Button, Link, Stack, TextField, Typography } from '@mui/material';\nimport { useForm } from 'react-hook-form';\n\nexport interface LoginFormValues {\n  email: string;\n  password: string;\n}\n\ninterface LoginScreenProps {\n  onSubmit: (values: LoginFormValues) => Promise<void> | void;\n  onForgotPassword?: (email: string) => void;\n  onNavigateToSignUp?: () => void;\n  isSubmitting?: boolean;\n  errorMessage?: string | null;\n}\n\nexport const LoginScreen: React.FC<LoginScreenProps> = ({ onSubmit, onForgotPassword, onNavigateToSignUp, isSubmitting = false, errorMessage = null }) => {\n  const { register, handleSubmit, formState: { errors }, watch } = useForm<LoginFormValues>();\n\n  const handleFormSubmit = handleSubmit(async (values) => {\n    await onSubmit(values);\n  });\n\n  const emailValue = watch('email');\n\n  return (\n    <Box component={'section'} maxWidth={380} mx={'auto'} mt={8} px={4} py={5} borderRadius={2} boxShadow={3} bgcolor={'background.paper'}>\n      <Typography variant={'h5'} component={'h1'} gutterBottom>Log In</Typography>\n      <form onSubmit={handleFormSubmit} noValidate>\n        <Stack spacing={2}>\n          <TextField\n            type={'email'}\n            label={'Email'}\n            autoComplete={'email'}\n            {...register('email', {\n              required: 'Email is required.',\n              pattern: {\n                value: /[^@ \\t\\r\\n]+@[^@ \\t\\r\\n]+\\.[^@ \\t\\r\\n]+/,\n                message: 'Enter a valid email address.'\n              }\n            })}\n            error={Boolean(errors.email)}\n            helperText={errors.email?.message}\n            fullWidth\n          />\n          <TextField\n            type={'password'}\n            label={'Password'}\n            autoComplete={'current-password'}\n            {...register('password', { required: 'Password is required.' })}\n            error={Boolean(errors.password)}\n            helperText={errors.password?.message}\n            fullWidth\n          />\n          {errorMessage ? <Alert severity={'error'}>{errorMessage}</Alert> : null}\n          <Button type={'submit'} variant={'contained'} size={'large'} disabled={isSubmitting}>\n            {isSubmitting ? 'Signing in...' : 'Sign in'}\n          </Button>\n          <Stack direction={'row'} justifyContent={'space-between'} alignItems={'center'}>\n            <Link component={'button'} type={'button'} onClick={() => onForgotPassword && onForgotPassword(emailValue)} sx={{ p: 0 }}>\n              Forgot password?\n            </Link>\n            <Link component={'button'} type={'button'} onClick={onNavigateToSignUp} sx={{ p: 0 }}>\n              Create an account\n            </Link>\n          </Stack>\n        </Stack>\n      </form>\n    </Box>\n  );\n};\n"
  },
  {
    "module_id": "react_profile_screen",
    "module_name": "React Profile Screen",
    "language": "tsx",
    "inputs": ["user", "onUpdateProfile", "isUpdating", "statusMessage"],
    "outputs": ["<ProfileScreen /> component"],
    "documentation": "Profile screen with editable fields for display name, avatar URL, and bio. Includes optimistic form handling and success messaging.",
    "code": "import React, { useEffect, useMemo, useState } from 'react';\nimport { Alert, Avatar, Box, Button, Stack, TextField, Typography } from '@mui/material';\nimport { useForm } from 'react-hook-form';\n\nexport interface ProfileFormValues {\n  displayName: string;\n  email: string;\n  photoURL?: string;\n  bio?: string;\n}\n\ninterface ProfileScreenProps {\n  user: ProfileFormValues;\n  onUpdateProfile: (values: ProfileFormValues) => Promise<void> | void;\n  isUpdating?: boolean;\n  statusMessage?: string | null;\n}\n\nexport const ProfileScreen: React.FC<ProfileScreenProps> = ({ user, onUpdateProfile, isUpdating = false, statusMessage = null }) => {\n  const [isEditing, setIsEditing] = useState(false);\n  const { register, handleSubmit, reset, formState: { errors, isDirty } } = useForm<ProfileFormValues>({\n    defaultValues: user\n  });\n\n  useEffect(() => {\n    reset(user);\n  }, [reset, user]);\n\n  const initials = useMemo(() => {\n    return user.displayName?.split(' ').map((part) => part[0]?.toUpperCase()).join('').slice(0, 2) || 'U';\n  }, [user.displayName]);\n\n  const toggleEditing = () => {\n    if (isEditing) {\n      reset(user);\n    }\n    setIsEditing(!isEditing);\n  };\n\n  const submitHandler = handleSubmit(async (values) => {\n    await onUpdateProfile(values);\n    setIsEditing(false);\n  });\n\n  return (\n    <Box component={'section'} maxWidth={520} mx={'auto'} mt={6} px={4} py={5} borderRadius={2} boxShadow={3} bgcolor={'background.paper'}>\n      <Stack spacing={3} alignItems={'center'}>\n        <Avatar src={user.photoURL} sx={{ width: 96, height: 96, fontSize: 32 }}>\n          {initials}\n        </Avatar>\n        <Typography variant={'h5'} component={'h1'}>{user.displayName}</Typography>\n      </Stack>\n\n      <Box mt={4}>\n        <form onSubmit={submitHandler} noValidate>\n          <Stack spacing={2}>\n            <TextField\n              label={'Display Name'}\n              {...register('displayName', { required: 'Display name is required.' })}\n              error={Boolean(errors.displayName)}\n              helperText={errors.displayName?.message}\n              fullWidth\n              disabled={!isEditing}\n            />\n            <TextField\n              label={'Email'}\n              type={'email'}\n              {...register('email', { required: 'Email is required.' })}\n              error={Boolean(errors.email)}\n              helperText={errors.email?.message}\n              fullWidth\n              disabled\n            />\n            <TextField\n              label={'Photo URL'}\n              {...register('photoURL')}\n              fullWidth\n              disabled={!isEditing}\n            />\n            <TextField\n              label={'Bio'}\n              multiline\n              minRows={3}\n              {...register('bio')}\n              fullWidth\n              disabled={!isEditing}\n            />\n            {statusMessage ? <Alert severity={'success'}>{statusMessage}</Alert> : null}\n            <Stack direction={'row'} spacing={2} justifyContent={'flex-end'}>\n              <Button type={'button'} variant={'outlined'} onClick={toggleEditing}>\n                {isEditing ? 'Cancel' : 'Edit profile'}\n              </Button>\n              <Button type={'submit'} variant={'contained'} disabled={!isEditing || !isDirty || isUpdating}>\n                {isUpdating ? 'Saving...' : 'Save changes'}\n              </Button>\n            </Stack>\n          </Stack>\n        </form>\n      </Box>\n    </Box>\n  );\n};\n"
  },
  {
    "module_id": "firebase_email_auth",
    "module_name": "Firebase Email Auth",
    "language": "ts",
    "inputs": ["config", "auth", "payload"],
    "outputs": ["Firebase auth helpers"],
    "documentation": "Initialises Firebase app and exposes helpers for email/password authentication flows including sign up, sign in, password reset, and auth state subscription.",
    "setup_required": true,
    "setup_instructions": "1. Create a Firebase project at https://console.firebase.google.com\n2. Enable Email/Password authentication: Go to Authentication > Sign-in method > Enable Email/Password\n3. Get your Firebase config from Project Settings > General > Your apps\n4. Create a config file with your Firebase credentials (apiKey, authDomain, projectId, appId)",
    "code": "import { initializeApp, type FirebaseApp } from 'firebase/app';\nimport { getAuth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile, signOut, sendPasswordResetEmail, type Auth, type User } from 'firebase/auth';\n\nlet cachedApp: FirebaseApp | null = null;\nlet cachedAuth: Auth | null = null;\n\nexport interface FirebaseAuthConfig {\n  apiKey: string;\n  authDomain: string;\n  projectId: string;\n  appId: string;\n}\n\nexport interface SignUpPayload {\n  displayName: string;\n  email: string;\n  password: string;\n}\n\nexport const initFirebaseAuth = (config: FirebaseAuthConfig): Auth => {\n  if (!cachedApp) {\n    cachedApp = initializeApp(config);\n  }\n  if (!cachedAuth) {\n    cachedAuth = getAuth(cachedApp);\n  }\n  return cachedAuth;\n};\n\nexport const signUpWithEmail = async (auth: Auth, payload: SignUpPayload): Promise<User> => {\n  const result = await createUserWithEmailAndPassword(auth, payload.email, payload.password);\n  if (payload.displayName) {\n    await updateProfile(result.user, { displayName: payload.displayName });\n  }\n  return result.user;\n};\n\nexport const signInWithEmail = async (auth: Auth, email: string, password: string): Promise<User> => {\n  const result = await signInWithEmailAndPassword(auth, email, password);\n  return result.user;\n};\n\nexport const signOutCurrentUser = (auth: Auth): Promise<void> => {\n  return signOut(auth);\n};\n\nexport const sendPasswordReset = (auth: Auth, email: string): Promise<void> => {\n  return sendPasswordResetEmail(auth, email);\n};\n\nexport const subscribeToAuthChanges = (auth: Auth, callback: (user: User | null) => void) => {\n  return onAuthStateChanged(auth, callback);\n};\n\nexport const getCurrentUser = (auth: Auth): User | null => auth.currentUser;\n"
  },
  {
    "module_id": "firebase_realtime_db",
    "module_name": "Firebase Realtime Database",
    "language": "ts",
    "inputs": ["app", "db", "uid", "profile", "updates", "activity"],
    "outputs": ["Realtime database helpers"],
    "documentation": "Provides helpers to initialise the Firebase Realtime Database, persist user profiles, subscribe to updates, and append timeline activity records.",
    "setup_required": true,
    "setup_instructions": "1. In your Firebase project console, go to Realtime Database\n2. Click 'Create Database' and choose a location\n3. Start in test mode (or configure security rules for production)\n4. Add the databaseURL to your Firebase config\n5. Update security rules to protect user data (e.g., users can only read/write their own data)",
    "code": "import { child, get, getDatabase, onValue, push, ref, set, update, type DataSnapshot, type Database } from 'firebase/database';\nimport type { FirebaseApp } from 'firebase/app';\n\nlet cachedDb: Database | null = null;\n\nexport const initRealtimeDatabase = (app: FirebaseApp): Database => {\n  if (!cachedDb) {\n    cachedDb = getDatabase(app);\n  }\n  return cachedDb;\n};\n\nexport const writeUserProfile = async (db: Database, uid: string, profile: Record<string, unknown>): Promise<void> => {\n  await set(ref(db, `users/${uid}`), profile);\n};\n\nexport const updateUserProfile = async (db: Database, uid: string, updates: Record<string, unknown>): Promise<void> => {\n  await update(ref(db, `users/${uid}`), updates);\n};\n\nexport const subscribeToUserProfile = (db: Database, uid: string, callback: (snapshot: DataSnapshot) => void) => {\n  const profileRef = ref(db, `users/${uid}`);\n  return onValue(profileRef, callback);\n};\n\nexport const fetchUserProfile = async (db: Database, uid: string): Promise<unknown> => {\n  const snapshot = await get(child(ref(db), `users/${uid}`));\n  return snapshot.exists() ? snapshot.val() : null;\n};\n\nexport const appendUserActivity = async (db: Database, uid: string, activity: Record<string, unknown>): Promise<void> => {\n  const listRef = ref(db, `users/${uid}/activity`);\n  await push(listRef, { ...activity, timestamp: Date.now() });\n};\n"
  },
  {
    "module_id": "react_hero_section",
    "module_name": "React Hero Section",
    "language": "tsx",
    "inputs": ["title", "subtitle", "ctaText", "ctaAction", "backgroundImage"],
    "outputs": ["<HeroSection /> component"],
    "documentation": "Full-width hero section for landing pages with headline, subtitle, CTA button, and optional background image. Responsive and customizable.",
    "code": "import React from 'react';\nimport { Box, Button, Container, Stack, Typography } from '@mui/material';\n\ninterface HeroSectionProps {\n  title: string;\n  subtitle?: string;\n  ctaText?: string;\n  ctaAction?: () => void;\n  backgroundImage?: string;\n  backgroundColor?: string;\n}\n\nexport const HeroSection: React.FC<HeroSectionProps> = ({\n  title,\n  subtitle,\n  ctaText = 'Get Started',\n  ctaAction,\n  backgroundImage,\n  backgroundColor = 'primary.main'\n}) => {\n  return (\n    <Box\n      sx={{\n        position: 'relative',\n        minHeight: { xs: '400px', md: '600px' },\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        background: backgroundImage\n          ? `linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url(${backgroundImage})`\n          : backgroundColor,\n        backgroundSize: 'cover',\n        backgroundPosition: 'center',\n        color: 'white',\n        textAlign: 'center',\n        py: 8\n      }}\n    >\n      <Container maxWidth=\"md\">\n        <Stack spacing={3} alignItems=\"center\">\n          <Typography\n            variant=\"h1\"\n            component=\"h1\"\n            sx={{\n              fontSize: { xs: '2.5rem', md: '4rem' },\n              fontWeight: 700,\n              textShadow: '2px 2px 4px rgba(0,0,0,0.3)'\n            }}\n          >\n            {title}\n          </Typography>\n          {subtitle && (\n            <Typography\n              variant=\"h5\"\n              component=\"p\"\n              sx={{\n                fontSize: { xs: '1.2rem', md: '1.5rem' },\n                maxWidth: '800px',\n                textShadow: '1px 1px 2px rgba(0,0,0,0.3)'\n              }}\n            >\n              {subtitle}\n            </Typography>\n          )}\n          {ctaAction && (\n            <Button\n              variant=\"contained\"\n              size=\"large\"\n              onClick={ctaAction}\n              sx={{\n                mt: 2,\n                px: 4,\n                py: 1.5,\n                fontSize: '1.2rem',\n                backgroundColor: 'white',\n                color: 'primary.main',\n                '&:hover': {\n                  backgroundColor: 'grey.100'\n                }\n              }}\n            >\n              {ctaText}\n            </Button>\n          )}\n        </Stack>\n      </Container>\n    </Box>\n  );\n};\n"
  },
  {
    "module_id": "react_feature_grid",
    "module_name": "React Feature Grid",
    "language": "tsx",
    "inputs": ["features"],
    "outputs": ["<FeatureGrid /> component"],
    "documentation": "Responsive grid layout displaying features with icons, titles, and descriptions. Perfect for showcasing product benefits on landing pages.",
    "code": "import React from 'react';\nimport { Box, Card, CardContent, Container, Grid, Typography } from '@mui/material';\nimport { styled } from '@mui/material/styles';\n\ninterface Feature {\n  icon: React.ReactNode;\n  title: string;\n  description: string;\n}\n\ninterface FeatureGridProps {\n  features: Feature[];\n  columns?: 2 | 3 | 4;\n}\n\nconst FeatureCard = styled(Card)(({ theme }) => ({\n  height: '100%',\n  display: 'flex',\n  flexDirection: 'column',\n  transition: 'transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out',\n  '&:hover': {\n    transform: 'translateY(-8px)',\n    boxShadow: theme.shadows[8]\n  }\n}));\n\nconst IconWrapper = styled(Box)(({ theme }) => ({\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  width: 64,\n  height: 64,\n  borderRadius: '50%',\n  backgroundColor: theme.palette.primary.main,\n  color: 'white',\n  marginBottom: theme.spacing(2),\n  fontSize: '2rem'\n}));\n\nexport const FeatureGrid: React.FC<FeatureGridProps> = ({ features, columns = 3 }) => {\n  return (\n    <Box sx={{ py: 8, backgroundColor: 'background.default' }}>\n      <Container maxWidth=\"lg\">\n        <Grid container spacing={4}>\n          {features.map((feature, index) => (\n            <Grid item xs={12} sm={6} md={12 / columns} key={index}>\n              <FeatureCard>\n                <CardContent sx={{ flexGrow: 1, textAlign: 'center', p: 4 }}>\n                  <Box sx={{ display: 'flex', justifyContent: 'center' }}>\n                    <IconWrapper>{feature.icon}</IconWrapper>\n                  </Box>\n                  <Typography variant=\"h5\" component=\"h3\" gutterBottom fontWeight={600}>\n                    {feature.title}\n                  </Typography>\n                  <Typography variant=\"body1\" color=\"text.secondary\">\n                    {feature.description}\n                  </Typography>\n                </CardContent>\n              </FeatureCard>\n            </Grid>\n          ))}\n        </Grid>\n      </Container>\n    </Box>\n  );\n};\n"
  },
  {
    "module_id": "react_image_gallery",
    "module_name": "React Image Gallery",
    "language": "tsx",
    "inputs": ["images", "onImageClick"],
    "outputs": ["<ImageGallery /> component"],
    "documentation": "Responsive masonry-style image gallery with lightbox support. Optimized for performance with lazy loading.",
    "code": "import React, { useState } from 'react';\nimport { Box, Container, Dialog, IconButton, ImageList, ImageListItem } from '@mui/material';\nimport CloseIcon from '@mui/icons-material/Close';\n\ninterface GalleryImage {\n  src: string;\n  alt: string;\n  title?: string;\n}\n\ninterface ImageGalleryProps {\n  images: GalleryImage[];\n  columns?: number;\n  onImageClick?: (image: GalleryImage, index: number) => void;\n}\n\nexport const ImageGallery: React.FC<ImageGalleryProps> = ({ images, columns = 3, onImageClick }) => {\n  const [lightboxOpen, setLightboxOpen] = useState(false);\n  const [selectedImage, setSelectedImage] = useState<GalleryImage | null>(null);\n\n  const handleImageClick = (image: GalleryImage, index: number) => {\n    setSelectedImage(image);\n    setLightboxOpen(true);\n    if (onImageClick) {\n      onImageClick(image, index);\n    }\n  };\n\n  const handleClose = () => {\n    setLightboxOpen(false);\n    setSelectedImage(null);\n  };\n\n  return (\n    <>\n      <Container maxWidth=\"lg\" sx={{ py: 4 }}>\n        <ImageList variant=\"masonry\" cols={columns} gap={8}>\n          {images.map((image, index) => (\n            <ImageListItem\n              key={index}\n              sx={{\n                cursor: 'pointer',\n                transition: 'transform 0.3s ease',\n                '&:hover': {\n                  transform: 'scale(1.05)',\n                  zIndex: 1\n                }\n              }}\n              onClick={() => handleImageClick(image, index)}\n            >\n              <img\n                src={image.src}\n                alt={image.alt}\n                loading=\"lazy\"\n                style={{\n                  borderRadius: '8px',\n                  display: 'block',\n                  width: '100%'\n                }}\n              />\n            </ImageListItem>\n          ))}\n        </ImageList>\n      </Container>\n\n      <Dialog\n        open={lightboxOpen}\n        onClose={handleClose}\n        maxWidth=\"lg\"\n        fullWidth\n        PaperProps={{\n          sx: {\n            backgroundColor: 'rgba(0, 0, 0, 0.9)',\n            boxShadow: 'none'\n          }\n        }}\n      >\n        <IconButton\n          onClick={handleClose}\n          sx={{\n            position: 'absolute',\n            right: 8,\n            top: 8,\n            color: 'white',\n            zIndex: 1\n          }}\n        >\n          <CloseIcon />\n        </IconButton>\n        {selectedImage && (\n          <Box\n            sx={{\n              display: 'flex',\n              justifyContent: 'center',\n              alignItems: 'center',\n              p: 2\n            }}\n          >\n            <img\n              src={selectedImage.src}\n              alt={selectedImage.alt}\n              style={{\n                maxWidth: '100%',\n                maxHeight: '90vh',\n                objectFit: 'contain'\n              }}\n            />\n          </Box>\n        )}\n      </Dialog>\n    </>\n  );\n};\n"
  },
  {
    "module_id": "react_image_uploader",
    "module_name": "React Image Uploader",
    "language": "tsx",
    "inputs": ["onUpload", "maxFiles", "acceptedTypes"],
    "outputs": ["<ImageUploader /> component"],
    "documentation": "Drag-and-drop image uploader with preview, file validation, and progress tracking. Supports multiple files and custom upload handlers.",
    "code": "import React, { useCallback, useState } from 'react';\nimport { Box, Button, IconButton, LinearProgress, Paper, Stack, Typography } from '@mui/material';\nimport CloudUploadIcon from '@mui/icons-material/CloudUpload';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport ImageIcon from '@mui/icons-material/Image';\n\ninterface UploadedFile {\n  file: File;\n  preview: string;\n  progress: number;\n}\n\ninterface ImageUploaderProps {\n  onUpload: (files: File[]) => Promise<void>;\n  maxFiles?: number;\n  maxSizeMB?: number;\n  acceptedTypes?: string[];\n}\n\nexport const ImageUploader: React.FC<ImageUploaderProps> = ({\n  onUpload,\n  maxFiles = 5,\n  maxSizeMB = 5,\n  acceptedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif']\n}) => {\n  const [files, setFiles] = useState<UploadedFile[]>([]);\n  const [isDragging, setIsDragging] = useState(false);\n  const [uploading, setUploading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const validateFile = (file: File): string | null => {\n    if (!acceptedTypes.includes(file.type)) {\n      return `File type ${file.type} not accepted`;\n    }\n    if (file.size > maxSizeMB * 1024 * 1024) {\n      return `File size exceeds ${maxSizeMB}MB`;\n    }\n    return null;\n  };\n\n  const handleFiles = useCallback((fileList: FileList) => {\n    setError(null);\n    const newFiles: UploadedFile[] = [];\n\n    Array.from(fileList).forEach((file) => {\n      const validationError = validateFile(file);\n      if (validationError) {\n        setError(validationError);\n        return;\n      }\n\n      if (files.length + newFiles.length >= maxFiles) {\n        setError(`Maximum ${maxFiles} files allowed`);\n        return;\n      }\n\n      newFiles.push({\n        file,\n        preview: URL.createObjectURL(file),\n        progress: 0\n      });\n    });\n\n    setFiles((prev) => [...prev, ...newFiles]);\n  }, [files.length, maxFiles, acceptedTypes, maxSizeMB]);\n\n  const handleDrop = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragging(false);\n    if (e.dataTransfer.files) {\n      handleFiles(e.dataTransfer.files);\n    }\n  }, [handleFiles]);\n\n  const handleRemove = (index: number) => {\n    setFiles((prev) => {\n      const updated = [...prev];\n      URL.revokeObjectURL(updated[index].preview);\n      updated.splice(index, 1);\n      return updated;\n    });\n  };\n\n  const handleUpload = async () => {\n    setUploading(true);\n    setError(null);\n    try {\n      await onUpload(files.map((f) => f.file));\n      files.forEach((f) => URL.revokeObjectURL(f.preview));\n      setFiles([]);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Upload failed');\n    } finally {\n      setUploading(false);\n    }\n  };\n\n  return (\n    <Box sx={{ width: '100%', maxWidth: 600, mx: 'auto' }}>\n      <Paper\n        onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}\n        onDragLeave={() => setIsDragging(false)}\n        onDrop={handleDrop}\n        sx={{\n          p: 4,\n          textAlign: 'center',\n          border: '2px dashed',\n          borderColor: isDragging ? 'primary.main' : 'grey.300',\n          backgroundColor: isDragging ? 'action.hover' : 'background.paper',\n          transition: 'all 0.3s ease'\n        }}\n      >\n        <CloudUploadIcon sx={{ fontSize: 64, color: 'primary.main', mb: 2 }} />\n        <Typography variant=\"h6\" gutterBottom>\n          Drag & drop images here\n        </Typography>\n        <Typography variant=\"body2\" color=\"text.secondary\" gutterBottom>\n          or\n        </Typography>\n        <Button variant=\"contained\" component=\"label\">\n          Browse Files\n          <input\n            type=\"file\"\n            hidden\n            multiple\n            accept={acceptedTypes.join(',')}\n            onChange={(e) => e.target.files && handleFiles(e.target.files)}\n          />\n        </Button>\n        <Typography variant=\"caption\" display=\"block\" sx={{ mt: 2 }} color=\"text.secondary\">\n          Max {maxFiles} files, up to {maxSizeMB}MB each\n        </Typography>\n      </Paper>\n\n      {error && (\n        <Typography color=\"error\" sx={{ mt: 2, textAlign: 'center' }}>\n          {error}\n        </Typography>\n      )}\n\n      {files.length > 0 && (\n        <Box sx={{ mt: 3 }}>\n          <Stack spacing={2}>\n            {files.map((uploadedFile, index) => (\n              <Paper key={index} sx={{ p: 2 }}>\n                <Stack direction=\"row\" alignItems=\"center\" spacing={2}>\n                  <Box\n                    component=\"img\"\n                    src={uploadedFile.preview}\n                    alt=\"Preview\"\n                    sx={{ width: 60, height: 60, objectFit: 'cover', borderRadius: 1 }}\n                  />\n                  <Box sx={{ flexGrow: 1 }}>\n                    <Typography variant=\"body2\" noWrap>\n                      {uploadedFile.file.name}\n                    </Typography>\n                    <Typography variant=\"caption\" color=\"text.secondary\">\n                      {(uploadedFile.file.size / 1024 / 1024).toFixed(2)} MB\n                    </Typography>\n                  </Box>\n                  <IconButton onClick={() => handleRemove(index)} size=\"small\">\n                    <DeleteIcon />\n                  </IconButton>\n                </Stack>\n              </Paper>\n            ))}\n          </Stack>\n\n          <Button\n            variant=\"contained\"\n            fullWidth\n            sx={{ mt: 2 }}\n            onClick={handleUpload}\n            disabled={uploading}\n          >\n            {uploading ? 'Uploading...' : `Upload ${files.length} file(s)`}\n          </Button>\n        </Box>\n      )}\n    </Box>\n  );\n};\n"
  },
  {
    "module_id": "react_cta_section",
    "module_name": "React CTA Section",
    "language": "tsx",
    "inputs": ["title", "description", "primaryAction", "secondaryAction"],
    "outputs": ["<CTASection /> component"],
    "documentation": "Call-to-action section for landing pages with heading, description, and action buttons. Customizable styling and layout.",
    "code": "import React from 'react';\nimport { Box, Button, Container, Stack, Typography } from '@mui/material';\n\ninterface CTASectionProps {\n  title: string;\n  description?: string;\n  primaryButtonText?: string;\n  primaryButtonAction?: () => void;\n  secondaryButtonText?: string;\n  secondaryButtonAction?: () => void;\n  backgroundColor?: string;\n  variant?: 'default' | 'gradient';\n}\n\nexport const CTASection: React.FC<CTASectionProps> = ({\n  title,\n  description,\n  primaryButtonText = 'Get Started',\n  primaryButtonAction,\n  secondaryButtonText,\n  secondaryButtonAction,\n  backgroundColor = 'primary.main',\n  variant = 'default'\n}) => {\n  const background = variant === 'gradient'\n    ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'\n    : backgroundColor;\n\n  return (\n    <Box\n      sx={{\n        background,\n        color: 'white',\n        py: 8,\n        textAlign: 'center'\n      }}\n    >\n      <Container maxWidth=\"md\">\n        <Typography\n          variant=\"h3\"\n          component=\"h2\"\n          gutterBottom\n          fontWeight={700}\n          sx={{ mb: 2 }}\n        >\n          {title}\n        </Typography>\n        {description && (\n          <Typography\n            variant=\"h6\"\n            component=\"p\"\n            sx={{ mb: 4, opacity: 0.9, maxWidth: 700, mx: 'auto' }}\n          >\n            {description}\n          </Typography>\n        )}\n        <Stack\n          direction={{ xs: 'column', sm: 'row' }}\n          spacing={2}\n          justifyContent=\"center\"\n        >\n          <Button\n            variant=\"contained\"\n            size=\"large\"\n            onClick={primaryButtonAction}\n            sx={{\n              backgroundColor: 'white',\n              color: 'primary.main',\n              px: 4,\n              py: 1.5,\n              '&:hover': {\n                backgroundColor: 'grey.100'\n              }\n            }}\n          >\n            {primaryButtonText}\n          </Button>\n          {secondaryButtonText && secondaryButtonAction && (\n            <Button\n              variant=\"outlined\"\n              size=\"large\"\n              onClick={secondaryButtonAction}\n              sx={{\n                borderColor: 'white',\n                color: 'white',\n                px: 4,\n                py: 1.5,\n                '&:hover': {\n                  borderColor: 'white',\n                  backgroundColor: 'rgba(255, 255, 255, 0.1)'\n                }\n              }}\n            >\n              {secondaryButtonText}\n            </Button>\n          )}\n        </Stack>\n      </Container>\n    </Box>\n  );\n};\n"
  },
  {
    "module_id": "firebase_storage",
    "module_name": "Firebase Storage",
    "language": "ts",
    "inputs": ["app", "storage", "file", "path"],
    "outputs": ["Firebase storage helpers"],
    "documentation": "Provides helpers to upload images/files to Firebase Storage, retrieve download URLs, delete files, and track upload progress.",
    "setup_required": true,
    "setup_instructions": "1. In your Firebase project console, go to Storage\n2. Click 'Get Started' and set up security rules\n3. Choose a location for your storage bucket\n4. Update security rules based on your needs (e.g., authenticated users only)\n5. Add the storageBucket URL to your Firebase config",
    "code": "import { deleteObject, getDownloadURL, ref, uploadBytesResumable, type FirebaseStorage, type StorageReference, type UploadTask } from 'firebase/storage';\nimport { getStorage } from 'firebase/storage';\nimport type { FirebaseApp } from 'firebase/app';\n\nlet cachedStorage: FirebaseStorage | null = null;\n\nexport const initFirebaseStorage = (app: FirebaseApp): FirebaseStorage => {\n  if (!cachedStorage) {\n    cachedStorage = getStorage(app);\n  }\n  return cachedStorage;\n};\n\nexport const uploadFile = (\n  storage: FirebaseStorage,\n  file: File,\n  path: string,\n  onProgress?: (progress: number) => void\n): UploadTask => {\n  const storageRef = ref(storage, path);\n  const uploadTask = uploadBytesResumable(storageRef, file);\n\n  if (onProgress) {\n    uploadTask.on('state_changed', (snapshot) => {\n      const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\n      onProgress(progress);\n    });\n  }\n\n  return uploadTask;\n};\n\nexport const uploadFileAndGetURL = async (\n  storage: FirebaseStorage,\n  file: File,\n  path: string,\n  onProgress?: (progress: number) => void\n): Promise<string> => {\n  const uploadTask = uploadFile(storage, file, path, onProgress);\n  await uploadTask;\n  const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);\n  return downloadURL;\n};\n\nexport const getFileURL = async (storage: FirebaseStorage, path: string): Promise<string> => {\n  const storageRef = ref(storage, path);\n  return await getDownloadURL(storageRef);\n};\n\nexport const deleteFile = async (storage: FirebaseStorage, path: string): Promise<void> => {\n  const storageRef = ref(storage, path);\n  await deleteObject(storageRef);\n};\n\nexport const createStorageRef = (storage: FirebaseStorage, path: string): StorageReference => {\n  return ref(storage, path);\n};\n"
  }
]
